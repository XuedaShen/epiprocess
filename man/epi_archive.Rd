% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/epi_archive.R
\name{epi_archive}
\alias{epi_archive}
\title{Archive (data version history) for an \code{epi_df} object}
\description{
Archive (data version history) for an \code{epi_df} object

Archive (data version history) for an \code{epi_df} object
}
\details{
Contains version history for an \code{epi_df} object, and enables fast querying
of snapshots of the \code{epi_df} object as of certain "issues" (versions).
Version history can be input as a data frame combining full snapshots of the
\code{epi_df} as of several issue times, or using only the newly added or
revised rows for each issue, or using some combination of these two
(including "updates" for things that didn't actually change).
Last-observation-carried-forward (LOCF) is used to data in between recorded
updates. Currently, deletions must be represented as revising a row to a
special state (e.g., making the entries \code{NA} or including a special
column that flags the data as removed and performing post-processing), and
the archive is unaware of what this state is.
}
\examples{

update.df =
  tibble::tribble(
    ~geo_value, ~time_value, ~issue, ~value,
    ## update history of geo1 for reference time 2021-01-01:
    ##   (1 day of latency in initial report)
    "geo1", as.Date("2021-01-01"), as.Date("2021-01-02"), 5.0,
    ##   (revised upward)
    "geo1", as.Date("2021-01-01"), as.Date("2021-01-03"), 9.0,
    ##   (revised upward)
    "geo1", as.Date("2021-01-01"), as.Date("2021-01-10"), 9.2,
    ## update history of geo1 for reference time 2021-01-02:
    ##   (1 day of latency in initial report)
    "geo1", as.Date("2021-01-02"), as.Date("2021-01-03"), 8.0,
    ##   (redundant "update" row; we will already be using LOCF to fill in)
    "geo1", as.Date("2021-01-02"), as.Date("2021-01-04"), 8.0,
    ##   (replaced with NA)
    "geo1", as.Date("2021-01-02"), as.Date("2021-01-10"), NA_real_,
    ## update history of geo1 for reference time 2021-01-05 (suppose data set skips the 3rd and 4th)
    ##   (1 day of latency in initial report)
    "geo1", as.Date("2021-01-05"), as.Date("2021-01-06"), 13.0,
  )

## update.df actually contains update data through issue 2021-01-11, but the
## data set was not reported to change from 2021-01-10 to 2021-01-11
epi.tibble.archive = epi_archive$new(update.df, max.issue=as.Date("2021-01-11"))

## The snapshot as of issue 2021-01-03 just looks like the updates in issue
## 2021-01-03, because all past measurements were updated in this issue (we
## don't need to do any LOCF to obtain the snapshot).
epi.tibble.archive$epi_df_as_of(as.Date("2021-01-03"))

## The snapshot as of issue 2021-01-05 uses LOCF on the first two geo-time
## combinations. Note that there is no entry for `time_value` 2021-01-05, as the
## initial version of this data was not available until issue 2021-01-06.
epi.tibble.archive$epi_df_as_of(as.Date("2021-01-05"))

## The snapshot as of issue 2021-01-06 does include the measurement for
## `time_value` 2021-01-05.
epi.tibble.archive$epi_df_as_of(as.Date("2021-01-06"))

## (Don't automatically run this example as it involves network access and querying the API)
if (FALSE) {
  library(dplyr)
  ## (delphi.epidata package is on GitHub in cmu-delphi/delphi-epidata-r)
  update.df.2 =
    delphi.epidata::covidcast("jhu-csse", "confirmed_incidence_num",
                              "day", "state",
                              delphi.epidata::epirange(12340101,34560101), c("ak","al"),
                              issues = delphi.epidata::epirange(12340101,34560101)) \%>\%
    delphi.epidata::fetch_tbl()
  snapshot.df.2a =
    delphi.epidata::covidcast("jhu-csse", "confirmed_incidence_num",
                              "day", "state",
                              delphi.epidata::epirange(12340101,34560101), c("ak","al"),
                              as_of = 20201014) \%>\%
    delphi.epidata::fetch_tbl()
  snapshot.df.2b =
    delphi.epidata::covidcast("jhu-csse", "confirmed_incidence_num",
                              "day", "state",
                              delphi.epidata::epirange(12340101,34560101), c("ak","al"),
                              as_of = 20201028) \%>\%
    delphi.epidata::fetch_tbl()

  epi.tibble.archive.2 = epi_archive$new(update.df.2)
  all.equal(
    as_tibble(epi.tibble.archive.2$epi_df_as_of(as.Date("2020-10-14"))),
    as_tibble(as.epi_df(snapshot.df.2a)),
    check.attributes = FALSE)
  all.equal(
    as_tibble(epi.tibble.archive.2$epi_df_as_of(as.Date("2020-10-28"))),
    as_tibble(as.epi_df(snapshot.df.2b)),
    check.attributes = FALSE)
}

}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{epi_archive$new()}}
\item \href{#method-epi_df_as_of}{\code{epi_archive$epi_df_as_of()}}
\item \href{#method-naming_info}{\code{epi_archive$naming_info()}}
\item \href{#method-max_issue}{\code{epi_archive$max_issue()}}
\item \href{#method-issues_with_updates}{\code{epi_archive$issues_with_updates()}}
\item \href{#method-update_DT_as_of}{\code{epi_archive$update_DT_as_of()}}
\item \href{#method-clone}{\code{epi_archive$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new \code{epi_archive} with the given update data.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{epi_archive$new(
  update.df,
  issue.colname = "issue",
  geo.colname = "geo_value",
  time.colname = "time_value",
  other.key.colnames = character(0L),
  max.issue = max(update.df[[issue.colname]])
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{update.df}}{the update data}

\item{\code{issue.colname}}{name of the column with the issue time of the corresponding updates; operations such as \code{sort}, \code{<=}, and \code{max} must make sense on this column, with earlier issues "less than" later issues}

\item{\code{geo.colname}}{the name of the column that will become \code{geo_value} in the \code{epi_df}}

\item{\code{time.colname}}{the name of the column that will become \code{time_value} in the \code{epi_df}}

\item{\code{other.key.colnames}}{the names of any other columns that would be used to index a single measurement in this data set, such as the age group the measurement corresponds to (if the data set includes an age group breakdown); there should only be a single row per issue-geo-time-other-key-cols combination.}

\item{\code{max.issue}}{the latest issue for which update data was available; defaults to the maximum issue time in the \code{update.df}, but if there were no additions or revisions in subsequent issues, it could be later.  However, due to details regarding database replica syncing times in upstream APIs, using the default might be safer than whatever we think the max issue should be.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
an \code{epi_archive} object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-epi_df_as_of"></a>}}
\if{latex}{\out{\hypertarget{method-epi_df_as_of}{}}}
\subsection{Method \code{epi_df_as_of()}}{
Get the \code{epi_df} as of some issue time
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{epi_archive$epi_df_as_of(issue)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{issue}}{the desired as-of issue time}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
an \code{epi_df} with data as of the specified issue time, \code{issue} recorded in the metadata, the geo column renamed to \code{geo_value} and time column to \code{time_value}, and the other key colnames recorded in the metadata
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-naming_info"></a>}}
\if{latex}{\out{\hypertarget{method-naming_info}{}}}
\subsection{Method \code{naming_info()}}{
Return the name settings in a list
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{epi_archive$naming_info()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-max_issue"></a>}}
\if{latex}{\out{\hypertarget{method-max_issue}{}}}
\subsection{Method \code{max_issue()}}{
Return the max issue value recorded by this archive (whether it had updates or not)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{epi_archive$max_issue()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-issues_with_updates"></a>}}
\if{latex}{\out{\hypertarget{method-issues_with_updates}{}}}
\subsection{Method \code{issues_with_updates()}}{
Return the issue values for which updates are
recorded in this archive (that is, whether they had updates in
the data frame used to form this archive, regardless of whether
those "updates" actually added or revised any data)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{epi_archive$issues_with_updates()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-update_DT_as_of"></a>}}
\if{latex}{\out{\hypertarget{method-update_DT_as_of}{}}}
\subsection{Method \code{update_DT_as_of()}}{
Return the recorded update data up through the given issue
value, inside a \code{data.table} object which is fine to
modify without copying.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{epi_archive$update_DT_as_of(issue)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{issue}}{the max issue value that should appear in the result}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{epi_archive$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
