% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/archive.R
\name{epi_archive}
\alias{epi_archive}
\title{\code{epi_archive} object}
\description{
An \code{epi_archive} is an R6 class which contains a data table
along with several relevant pieces of metadata. The data table can be seen
as the full archive (version history) for some signal variables of
interest.
}
\details{
An \code{epi_archive} is an R6 class which contains a data table \code{DT}, of
class \code{data.table} from the \code{data.table} package, with (at least) the
following columns:
\itemize{
\item \code{geo_value}: the geographic value associated with each row of measurements.
\item \code{time_value}: the time value associated with each row of measurements.
\item \code{version}: the time value specifying the version for each row of
measurements. For example, if in a given row the \code{version} is January 15,
2022 and \code{time_value} is January 14, 2022, then this row contains the
measurements of the data for January 14, 2022 that were available one day
later.
}

The data table \code{DT} has key variables \code{geo_value}, \code{time_value}, \code{version},
as well as any others (these can be specified when instantiating the
\code{epi_archive} object via the \code{other_keys} argument, and/or set by operating
on \code{DT} directly). There can only be a single row per unique combination of
key variables, and thus the key variables are critical for figuring out how
to generate a snapshot of data from the archive, as of a given version
(also described below).

In general, last observation carried forward (LOCF) is used to data in
between recorded versions. Currently, deletions must be represented as
revising a row to a special state (e.g., making the entries \code{NA} or
including a special column that flags the data as removed and performing
some kind of post-processing), and the archive is unaware of what this
state is.

\strong{A word of caution:} R6 objects, unlike most other objects in R, have
reference semantics. A primary consequence of this is that objects are not
copied when modified. You can read more about this in Hadley Wickham's
\href{https://adv-r.hadley.nz/r6.html#r6-semantics}{Advanced R} book.
}
\section{Metadata}{

The following pieces of metadata are included as fields in an \code{epi_archive}
object:
\itemize{
\item \code{geo_type}: the type for the geo values.
\item \code{time_type}: the type for the time values.
\item \code{additional_metadata}: list of additional metadata for the data archive.
}

Unlike an \code{epi_df} object, metadata for an \code{epi_archive} object \code{x} can be
accessed (and altered) directly, as in \code{x$geo_type} or \code{x$time_type},
etc. Like an \code{epi_df} object, the \code{geo_type} and \code{time_type} fields in the
metadata of an \code{epi_archive} object are not currently used by any
downstream functions in the \code{epiprocess} package, and serve only as useful
bits of information to convey about the data set at hand.
}

\section{Generating Snapshots}{

An \code{epi_archive} object can be used to generate a snapshot of the data in
\code{epi_df} format, which represents the most up-to-date values of the signal
variables, as of the specified version. This is accomplished by calling the
\code{as_of()} method for an \code{epi_archive} object \code{x}, for example:\preformatted{x$as_of(as.Date("2022-01-15"))
}

to generate a snapshot as of January 15, 2022. More details on the
\code{as_of()} method are documented below.
}

\section{Sliding Computations}{

We can run a sliding computation over an \code{epi_archive} object, much like
\code{epi_slide()} does for an \code{epi_df} object. This is accomplished by calling
the \code{slide()} method for an \code{epi_archive} object, which works similarly to
the way \code{epi_slide()} works for an \code{epi_df} object, but with one key
difference: it is version-aware. That is, for an \code{epi_archive} object, the
sliding computation at any given reference time point t is performed on
\strong{data that would have been available as of t}. More details on \code{slide()}
are documented below.
}

\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{epi_archive$new()}}
\item \href{#method-print}{\code{epi_archive$print()}}
\item \href{#method-as_of}{\code{epi_archive$as_of()}}
\item \href{#method-merge}{\code{epi_archive$merge()}}
\item \href{#method-slide}{\code{epi_archive$slide()}}
\item \href{#method-clone}{\code{epi_archive$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Creates a new \code{epi_archive} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{epi_archive$new(x, geo_type, time_type, other_keys, additional_metadata)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{A data frame, data table, or tibble, with columns \code{geo_value},
\code{time_value}, \code{version}, and then any additional number of columns.}

\item{\code{geo_type}}{Type for the geo values. If missing, then the function will
attempt to infer it from the geo values present; if this fails, then it
will be set to "custom".}

\item{\code{time_type}}{Type for the time values. If missing, then the function will
attempt to infer it from the time values present; if this fails, then it
will be set to "custom".}

\item{\code{other_keys}}{Character vector specifying the names of variables in \code{x}
that should be considered key variables (in the language of \code{data.table})
apart from "geo_value", "time_value", and "version".}

\item{\code{additional_metadata}}{List of additional metadata to attach to the
\code{epi_archive} object. The metadata will have \code{geo_type} and \code{time_type}
fields; named entries from the passed list or will be included as well.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An \code{epi_archive} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{epi_archive$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-as_of"></a>}}
\if{latex}{\out{\hypertarget{method-as_of}{}}}
\subsection{Method \code{as_of()}}{
Generates a snapshot in \code{epi_df} format as of a given version.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{epi_archive$as_of(max_version, min_time_value = -Inf)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{max_version}}{Time value specifying the max version to permit in the
snapshot. That is, the snapshot will comprise the unique rows of the
current archive data that represent the most up-to-date signal values, as
of the specified \code{max_version} (and whose time values are at least
\code{min_time_value}.)}

\item{\code{min_time_value}}{Time value specifying the min time value to permit in
the snapshot. Default is \code{-Inf}, which effectively means that there is no
minimum considered.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An \code{epi_df} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-merge"></a>}}
\if{latex}{\out{\hypertarget{method-merge}{}}}
\subsection{Method \code{merge()}}{
Merges another \code{data.table} with the current one, and allows for
a post-filling of \code{NA} values by last observation carried forward (LOCF).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{epi_archive$merge(y, ..., locf = TRUE, nan = NA)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{y}}{A \code{data.table} to join to the current one. This can instead be an
\code{epi_archive} object, in which case its underlying data table is joined.}

\item{\code{...}}{Named arguments to pass to \code{data.table::merge.data.table()}, which
is used for the join (with all default settings as in this function). For
example, passing \code{all = TRUE} will perform a full join.}

\item{\code{locf}}{Should LOCF be used after joining on all non-key columns? This
will take the latest version of each signal value and propogate it forward
to fill in gaps that appear after merging. Default is \code{TRUE}.}

\item{\code{nan}}{Should \code{NaN} values be treated as \code{NA} values in the post-filling
step?  Default is \code{NA}, which means that they are treated as \code{NA} values; if}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Nothing (the underlying data table overwritten with the merged one).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-slide"></a>}}
\if{latex}{\out{\hypertarget{method-slide}{}}}
\subsection{Method \code{slide()}}{
Slides a given function over variables in an \code{epi_archive}
object. Windows are \strong{always right-aligned}, unlike \code{epi_slide()}. The
other arguments are as in \code{epi_slide()}, and its documentation gives more
details on their useage. The exception is the \code{by} argument, which used to
specify the grouping upfront (whereas in an \code{epi_df}, this would be
accomplished by a call to \code{dplyr::group_by()} that precedes a call to
\code{epi_df()}). See the archive vignette for examples.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{epi_archive$slide(
  f,
  ...,
  n = 14,
  complete = FALSE,
  new_col_name = "slide_value",
  as_list_col = FALSE,
  time_step,
  by
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{f}}{Function or formula to slide over variables in \code{x}. To "slide" means
to apply a function or formula over a running window of \code{n} time steps
(where one time step is typically one day or one week). If a function, \code{f}
must take \code{x}, a data frame with the same column names as the original
object; followed by any number of named arguments; and ending with
\code{...}. If a formula, \code{f} can operate directly on columns accessed via
\code{.x$var}, as in \code{~ mean(.x$var)} to compute a mean of a column \code{var} over a
sliding window of \code{n} time steps.}

\item{\code{...}}{Additional arguments to pass to the function or formula specified
via \code{f}. Alternatively, if \code{f} is missing, then the current argument is
interpreted as an expression for tidy evaluation.}

\item{\code{n}}{Number of time steps to use in the running window. For example, if
\code{n = 5}, one time step is one day, and the alignment is "right", then to
produce a value on November 5, we apply the given function or formula to
data in between November 1 and 5. Default is 14.}

\item{\code{complete}}{Should the slide function be run over complete windows only?
Default is \code{FALSE}, which allows for computation on partial windows.}

\item{\code{new_col_name}}{String indicating the name of the new column that will
contain the derivative values. Default is "slide_value"; note that setting
\code{new_col_name} equal to an existing column name will overwrite this column.}

\item{\code{as_list_col}}{Should the new column be stored as a list column? Default
is \code{FALSE}, in which case a list object returned by \code{f} would be unnested
(using \code{tidyr::unnest()}), and the names of the resulting columns are given
by prepending \code{new_col_name} to the names of the list elements.}

\item{\code{time_step}}{Optional function used to define the meaning of one time
step, which if specified, overrides the default choice based on the
\code{time_value} column. This function must take a positive integer and return
an object of class \code{lubridate::period}. For example, we can use \code{time_step = lubridate::hours} in order to set the time step to be one hour (this
would only be meaningful if \code{time_value} is of class \code{POSIXct}).}

\item{\code{by}}{The variable(s) to group by before slide computation. If missing,
then the keys in the underlying data table, excluding \code{time_value} and
\code{version}, will be used for grouping.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A tibble with the grouping variables, \code{time_value}, and a new column
named according to the \code{new_col_name} argument, with the slide values.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{epi_archive$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
