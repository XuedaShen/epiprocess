---
title: 5. Sensorization blah blah
description: An introductory tutorial with examples.
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{5. Sensorization blah blah}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

As a more sophisticated example, here we show how to *sensorize* the doctor 
visits signal. The sensor values are defined by the predicted values from a 
local (in time) regression of past case rates (response) on past doctor visits 
(covariate).

```{r, eval = FALSE}
# Regression for doctor visits sensorization
dv_regression = function(x, m = 3, ...) {
  n = nrow(x)
  if (n <= m+1) return(NA) # Take care of trivial case
  
  return(tryCatch(suppressWarnings(suppressMessages({
    # Fit a regression, leaving out the last m days of data
    lm_obj = lm(value.y ~ value.x, data = x[1:(n-m+1), ])
    
    # Form prediction for the last day of data, and return
    predict(lm_obj, newdata = x[n, ])
  })),
  error = function(e) return(NA)))
}

# Fetch doctor visits signal and join it to case rates
joined = suppressMessages(
  covidcast_signal(data_source = "doctor-visits", 
                   signal = "smoothed_adj_cli", 
                   start_day = start_day, end_day = end_day, 
                   geo_type = "state", geo_values = geo_values)) %>%
  full_join(signals[[2]], by = c("geo_value", "time_value"))
 
# Perform sensorization for each state; use the last n = 56 days (8 weeks) of 
# data, minus the last m = 3 days, for the regression
slide_by_geo(joined, slide_fun = dv_regression, n = 56, m = 3, 
             col_name = "sensor") %>%
  select(geo_value, time_value, value.x, value.y, sensor) %>%
  arrange(geo_value) %>% 
  head(10)
```

Above, the first 4 elements are `NA` because of insufficient training data (we 
need at least 2 training samples for simple linear regression, and we omit the 
last 3 days of data).

## Returning complex objects

As a final example, we show how to use `slide_by_geo()` to output more complex
objects. We amend the last example so that `dv_regression()` returns both the
predicted value (sensor) and the fitted linear model object. In order to use 
this with `slide_by_geo()`, we need to set the `col_type` argument to be "list":

```{r, eval = FALSE}
dv_regression = function(x, m = 3, ...) {
  n = nrow(x)
  if (n <= m+1) return(list(lm_obj = NA, sensor = NA)) # Trivial case
  
  return(tryCatch(suppressWarnings(suppressMessages({
    # Fit a regression, leaving out the last days of data
    n = nrow(x)
    lm_obj = lm(value.y ~ value.x, data = x[1:(n-m+1), ])
    
    # Form prediction for the last day of data
    sensor = predict(lm_obj, newdata = x[n, ])
    
    # Return the fitted lm object and prediction
    list(lm_obj = lm_obj, sensor = sensor)
  })),
  error = function(e) return(list(lm_obj = NA, sensor = NA))))
}

joined <- slide_by_geo(joined, slide_fun = dv_regression, n = 56, m = 3, 
                       col_name = "sensor_obj", col_type = "list")

class(joined$sensor_obj)
names(joined$sensor_obj[[5]]) # The first 4 are lists filled with NAs
joined$sensor_obj[[5]]$lm_obj
joined$sensor_obj[[5]]$sensor
```

This allows for post-inspection of the sensor models, which may be helpful for
diagnostic purposes. Note the way in which we structure the return argument in 
`dv_regression()` in its failure cases: it is always a list with the same named
arguments. This helps keep the post-inspection code just a bit more simple (it
is already a hairy enough, to protect against extracting coefficients from `NA` 
objects).

```{r, eval = FALSE}
joined %>% 
  rowwise() %>%
  mutate(sensor = sensor_obj$sensor, 
         intercept = ifelse(isTRUE(is.na(sensor_obj$lm_obj)), NA,
                            coef(sensor_obj$lm_obj)[1]),
         slope = ifelse(isTRUE(is.na(sensor_obj$lm_obj)), NA, 
                        coef(sensor_obj$lm_obj)[2])) %>%
  select(geo_value, time_value, sensor, intercept, slope) %>%
  arrange(geo_value) %>% 
  head(20)
```