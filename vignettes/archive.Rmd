---
title: 7. Work with issue dates and archive objects
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{7. Work with issue dates and archive objects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

*todo*

Basic stuff:

- introduce `epi_archive` object. comes with a main function `as_of()`, works
  something like this: 
    * if `z` is an `epi_archive` object, then we can use: 
    ```
    x <- as_of(z, issue = "2020-06-15")
    ```
    * here the object `x` will be an `epi_df` object
    * the function `as_of()` by default returns the latest observation (defined
    by unique combo of `geo_value` and `time_value` columns being equal) whose
    issue doesn't surpass the specified one 
    * there should be some functionality for specifying what uniquely defines an
    observation (e.g., more than just those two columns, could be an `age_group`
    column as well; basically, as way of specifying non-signal columns)
    * there should also be some functionality for getting all observations (not
    just the latest) whose issue doesn't surpass the specified one
    
Slide stuff:

- critically, the function `epi_slide()` can apply to an `epi_archive` object!
- this allows us to do honest forecaster training. basically, replaces `epival`
(we shouldn't need a separate package ...)  
- so `epi_slide()` checks what object it's being given
  * if an `epi_df`, it works as it does currently
  * if an `epi_archive`, then for each working time value, it uses `as_of()` to
  only return the data you would have had at that time (and whose time value is
  withing `n` trailing time steps of the specified one)
- demo this in the vignette with the hand-built AR forecaster. the `epi_predict` 
package can and still should be built, to contain more fancy forecasters, and
potentially also scoring roles. but the functionality for *running* these will
be already built into `epiprocess`, just as a generalization of `epi_slide()`

```{r eval = FALSE}
update.df =
  tibble::tribble(
    ~geo_value, ~time_value, ~issue, ~value,
    ## update history of geo1 for reference time 2021-01-01:
    ##   (1 day of latency in initial report)
    "geo1", as.Date("2021-01-01"), as.Date("2021-01-02"), 5.0,
    ##   (revised upward)
    "geo1", as.Date("2021-01-01"), as.Date("2021-01-03"), 9.0,
    ##   (revised upward)
    "geo1", as.Date("2021-01-01"), as.Date("2021-01-10"), 9.2,
    ## update history of geo1 for reference time 2021-01-02:
    ##   (1 day of latency in initial report)
    "geo1", as.Date("2021-01-02"), as.Date("2021-01-03"), 8.0,
    ##   (redundant "update" row; we will already be using LOCF to fill in)
    "geo1", as.Date("2021-01-02"), as.Date("2021-01-04"), 8.0,
    ##   (replaced with NA)
    "geo1", as.Date("2021-01-02"), as.Date("2021-01-10"), NA_real_,
    ## update history of geo1 for reference time 2021-01-05 (suppose data set skips the 3rd and 4th)
    ##   (1 day of latency in initial report)
    "geo1", as.Date("2021-01-05"), as.Date("2021-01-06"), 13.0,
  )

## update.df actually contains update data through issue 2021-01-11, but the
## data set was not reported to change from 2021-01-10 to 2021-01-11
epi.tibble.archive = epi_archive$new(update.df, max.issue=as.Date("2021-01-11"))

## The snapshot as of issue 2021-01-03 just looks like the updates in issue
## 2021-01-03, because all past measurements were updated in this issue (we
## don't need to do any LOCF to obtain the snapshot).
epi.tibble.archive$epi_df_as_of(as.Date("2021-01-03"))

## The snapshot as of issue 2021-01-05 uses LOCF on the first two geo-time
## combinations. Note that there is no entry for `time_value` 2021-01-05, as the
## initial version of this data was not available until issue 2021-01-06.
epi.tibble.archive$epi_df_as_of(as.Date("2021-01-05"))

## The snapshot as of issue 2021-01-06 does include the measurement for
## `time_value` 2021-01-05.
epi.tibble.archive$epi_df_as_of(as.Date("2021-01-06"))

## (Don't automatically run this example as it involves network access and querying the API)
if (FALSE) {
  library(dplyr)
  ## (delphi.epidata package is on GitHub in cmu-delphi/delphi-epidata-r)
  update.df.2 =
    delphi.epidata::covidcast("jhu-csse", "confirmed_incidence_num",
                              "day", "state",
                              delphi.epidata::epirange(12340101,34560101), c("ak","al"),
                              issues = delphi.epidata::epirange(12340101,34560101)) %>%
    delphi.epidata::fetch_tbl()
  snapshot.df.2a =
    delphi.epidata::covidcast("jhu-csse", "confirmed_incidence_num",
                              "day", "state",
                              delphi.epidata::epirange(12340101,34560101), c("ak","al"),
                              as_of = 20201014) %>%
    delphi.epidata::fetch_tbl()
  snapshot.df.2b =
    delphi.epidata::covidcast("jhu-csse", "confirmed_incidence_num",
                              "day", "state",
                              delphi.epidata::epirange(12340101,34560101), c("ak","al"),
                              as_of = 20201028) %>%
    delphi.epidata::fetch_tbl()
  epi.tibble.archive.2 = epi_archive$new(update.df.2)
  all.equal(
    as_tibble(epi.tibble.archive.2$epi_df_as_of(as.Date("2020-10-14"))),
    as_tibble(as_epi_df(snapshot.df.2a)),
    check.attributes = FALSE)
  all.equal(
    as_tibble(epi.tibble.archive.2$epi_df_as_of(as.Date("2020-10-28"))),
    as_tibble(as_epi_df(snapshot.df.2b)),
    check.attributes = FALSE)
}
```