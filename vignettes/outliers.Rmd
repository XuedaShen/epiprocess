---
title: 6. Detect and correct outliers in signals
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{6. Detect and correct outliers in signals}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This vignette describes functionality for detecting and correcting outliers in
signals `detect_outliers()` and `correct_outliers()`. These functions are 
designed to be modular and extendable, so that you can provide your own outlier
detection and correction functions and use them with `epi_tibble` objects. We'll 
work state-level daily reported COVID-19 case counts in Florida and New Jersey.

```{r, message = FALSE, fig.width = 9, fig.height = 4}
library(covidcast)
library(epitools)
library(dplyr)
library(tidyr)
library(ggplot2)
theme_set(theme_bw())

x <- covidcast_signal(data_source = "jhu-csse",
                      signal = "confirmed_incidence_num",
                      start_day = "2020-06-01",
                      end_day = "2021-05-31",
                      geo_type = "state",
                      geo_values = c("fl", "nj"),
                      as_of = "2021-10-28") %>%
  select(geo_value, time_value, cases = value) %>%
  as.epi_tibble()

ggplot() +
  geom_line(data = x, mapping = aes(x = time_value, y = cases)) +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(vars(geo_value), scales = "free_y", nrow = 1) +
  scale_x_date(minor_breaks = "month", date_labels = "%b %y") +
  labs(x = "Date", y = "Reported COVID-19 counts")
```

There are multiple outliers in these data that a modeler may want to detect and
correct. We'll discuss those two tasks in turn.

## Outlier detection

The `detect_outliers()` function allows us to run multiple outlier detection 
methods, and then (optionally) combine the results from those methods. Here, 
we'll investigate outlier detection results from each of following methods.

1. Detection based on a rolling median, using `detect_outliers_rm()`, which 
  computes a rolling median on with a default window size of 21 time points 
  centered at the time point under consideration, and then computes thresholds 
  based on a multiplier times a rolling IQR computed on the residuals. 
2. Detection based on a seasonal-trend decomposition using LOESS (STL), using
  `detect_outliers_stl()`, which is similar to the rolling median method but 
  replaces the rolling median with fitted values from STL. 
3. Detection based on an STL decomposition, but without seasonality term, which
  amounts to smoothing using LOESS.

The outlier detection methods are specified using a `tibble` that is passed to 
`detect_outliers()`, with one row per method, and whose columms specify the
outlier detection function, any input arguments (only nondefault values need to 
be supplied), and an abbreviated name for the method used in tracking results.
Abbreviations "rm" and "stl" can be used for functions `detect_outliers_rm()` 
and `detect_outliers_stl()`, respectively.

```{r}
detection_methods = bind_rows(
  tibble(
    method = "rm",
    method_args = list(list(detect_negatives = TRUE,
                            detection_multiplier = 2.5)),
    method_abbr = "rm"
  ),
  tibble(
    method = "stl",
    method_args = list(list(detect_negatives = TRUE,
                            detection_multiplier = 2.5)),
    method_abbr = "stl_seasonal"
  ),
  tibble(
    method = "stl",
    method_args = list(list(detect_negatives = TRUE,
                            detection_multiplier = 2.5,
                            seasonal_period = NULL)),
    method_abbr = "stl_nonseasonal",
  )
)

detection_methods
```

Additionally, we'll form combined lower and upper thresholds, calculated as the
median of the lower and upper thresholds from the methods at each time point. 
Note that using this combined median threshold is equivalent to using a majority
vote across the base methods to determine whether a value is an outlier.

```{r}
x = x %>%
  group_by(geo_value) %>%
  detect_outliers(
    var = cases,
    methods = detection_methods,
    combiner = "median",
    new_col_name = "outlier_info")
```

The original `epi_tibble`, `x`, has now been updated to include a new column
called `outlier_info` with information about the detection thresholds and
possible replacement values from each method:

```{r}
x
```

```{r}
x %>% unnest(outlier_info)
```

With these results in hand, we can visualize them using the convenience function
`plot_outliers`:

```{r fig.width=7, fig.height=7}
plot_outliers(x = x,
              var = cases,
              outliers_col = outlier_info,
              include_bands = TRUE,
              combined_only = FALSE,
              facet_ncol = 1,
              facet_scales = "free_y")
```

It's a little hard to see what's going on with the results from all the methods
overlaid on top of each other. We can help by making plots for one `geo_value`
at a time and facetting by the `detection_method`:

```{r fig.width=7, fig.height=7}
plot_outliers(x = x %>% filter(geo_value == "fl"),
              var = cases,
              outliers_col = outlier_info,
              include_bands = TRUE,
              combined_only = FALSE,
              facet_ncol = 1,
              facet_vars = vars(detection_method))
```

```{r fig.width=7, fig.height=7}
plot_outliers(x = x %>% filter(geo_value == "nj"),
              var = cases,
              outliers_col = outlier_info,
              include_bands = TRUE,
              combined_only = FALSE,
              facet_ncol = 1,
              facet_vars = vars(detection_method))
```

Or we could just plot the combined results and suppress the bands:

```{r fig.width=7, fig.height=7}
plot_outliers(x = x,
              var = cases,
              outliers_col = outlier_info,
              include_bands = FALSE,
              combined_only = TRUE,
              facet_ncol = 1,
              facet_scales = "free_y")
```


## Outlier correction

TODO: fill this in.
