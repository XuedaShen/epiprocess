---
title: Compactify to remove LOCF values
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Compactify to remove LOCF values}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Removing LOCF data to save space

We need not even store rows that look like the last observation carried forward,
as they use up extra space. Furthermore, we already apply LOCF in the
epi_archive-related functions, such that the results should be the same with or
without the rows, aas long as use code does not rely on directly modifying
epi_archive's fields in a way that expects all the original records and breaks
if they are trimmed down.
 
There are three
different values that can be assigned to `compactify`:

* No argument: Does not put in LOCF values, and prints the first six LOCF values
that have been omitted but could have been placed.
* `TRUE`: Does not put in LOCF values, but doesn't print anything relating
to which values have been omitted.
* `FALSE`: Includes LOCF values.

For this example, we have one chart using LOCF values, while another doesn't
use them to illustrate LOCF. Notice how the head of the first dataset differs
from the second from the third value included.

```{r}
dt <- archive_cases_dv_subset$DT

locf_omitted <- as_epi_archive(dt)
locf_included <- as_epi_archive(dt,compactify = FALSE)

head(locf_omitted$DT)
head(locf_included$DT)
```
 
LOCF can mar the performance of dataset operations. As we can see, both 500
iterations of `filter` and 500 iterations of `as_of` are both faster when
the LOCF values are omitted.

```{r}
dt2 <- select(dt,-percent_cli)

locf_included_2 <- as_epi_archive(dt2,compactify=FALSE)
locf_omitted_2 <- as_epi_archive(dt2,compactify=TRUE)

nrow(locf_included_2$DT)
nrow(locf_omitted_2$DT)

iterate_filter <- function(my_ea) {
  for (i in 1:500) {
    dplyr::filter(my_ea$DT,version >= as.Date("2020-01-01") + i)
  }
}

# Performance of filtering
system.time(iterate_filter(locf_included_2))
system.time(iterate_filter(locf_omitted_2))

iterate_as_of <- function(my_ea) {
  for (i in 1:500) {
    my_ea$as_of(min(my_ea$DT$time_value) + i)
  }
}

# Performance of as_of
system.time(iterate_as_of(locf_included_2))
system.time(iterate_as_of(locf_omitted_2))


```
