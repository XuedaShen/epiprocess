---
title: Compactify to remove redundant archive data
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Compactify to remove redundant archive data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Removing redundant update data to save space

We do not need to store version update rows that look like the last version
carried forward (LVCF) for use with `epiprocess`'s' `epi_archive`-related
functions, as they all apply LVCF to fill in data between explicit updates. By
default, we even detect and remove these LVCF-redundant rows to save space; this
should not impact results as long as you do not directly work with the archive's
`DT` field in a way that expects these rows to remain.

There are three
different values that can be assigned to `compactify`:

* No argument: if there are LVCF-redundant rows, removes them and issues a
  warning with some information about what rows were removed
* `TRUE`: removes any LVCF-redundant rows without any warning or other feedback
* `FALSE`: keeps any LVCF-redundant rows without any warning or other feedback

For this example, we have one chart using LVCF values, while another doesn't
use them to illustrate LVCF. Notice how the head of the first dataset differs
from the second from the third value included.

```{r}
library(dplyr)

dt <- archive_cases_dv_subset$DT

lvcf_omitted <- as_epi_archive(dt)
lvcf_included <- as_epi_archive(dt,compactify = FALSE)

head(lvcf_omitted$DT)
head(lvcf_included$DT)
```
 
LVCF-redundant values can mar the performance of dataset operations. As the column
`case_rate_7d_av` has many more LVCF-redundant values than `percent_cli`, we will omit the
`percent_cli` column for comparing performance.

```{r}
dt2 <- select(dt,-percent_cli)

lvcf_included_2 <- as_epi_archive(dt2,compactify=FALSE)
lvcf_omitted_2 <- as_epi_archive(dt2,compactify=TRUE)
```

In this example, a huge proportion of the original version update data were
LVCF-redundant, and compactifying saves a large amount of space. The proportion
of data that is LVCF-redundant can vary widely between data sets, so we won't
always be this lucky.

```{r}
nrow(lvcf_included_2$DT)
nrow(lvcf_omitted_2$DT)
```


As we would expect, performing 200 iterations of `dplyr::filter` is faster when
the LVCF values are omitted.

```{r}
# Performance of filtering
iterate_filter <- function(my_ea) {
  for (i in 1:1000) {
    filter(my_ea$DT,version >= as.Date("2020-01-01") + i)
  }
}

elapsed_time <- function(fx) c(system.time(fx))[[3]]

speed_test <- function(f,name) {
  data.frame(
    operation = name,
    lvcf = elapsed_time(f(lvcf_included_2)),
    no_lvcf = elapsed_time(f(lvcf_omitted_2))
  )
}

speeds <- speed_test(iterate_filter,"filter_1000x")

```

We would also like to measure the speed of `epi_archive` methods.

```{r}
# Performance of as_of iterated 200 times
iterate_as_of <- function(my_ea) {
  for (i in 1:1000) {
    my_ea$as_of(min(my_ea$DT$time_value) + i - 1000)
  }
}

speeds <- rbind(speeds, speed_test(iterate_as_of,"as_of_1000x"))

# Performance of slide
slide_median <- function(my_ea) {
    my_ea$slide(median = median(case_rate_7d_av))
}

speeds <- rbind(speeds, speed_test(slide_median,"slide_median"))
```
Here is a detailed performance comparison:

```{r}
speeds_tidy <- tidyr::gather(speeds,key="is_lvcf",value="time_in_s",lvcf,no_lvcf)

library(ggplot2)

ggplot(speeds_tidy) +
  geom_bar(aes(x=is_lvcf,y=time_in_s,fill=operation),stat = "identity")
```
